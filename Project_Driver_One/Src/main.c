/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include "CortexM/CortexM4_Core_NVIC.h"
#include "CortexM/CortexM4_Core_SCB.h"
#include "Hal_Drivers/RCC/STM32F4xx_Hal_RCC.h"
#include "Hal_Drivers/Common/STM32F4xx_Hal_Def.h"
#include "CortexM/CortexM4_Core_SYSTICK.h"


#include <stdint.h>
#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif
static volatile uint_8 USART3_IRQ_Flage = 0;
static volatile uint_8 EXTI15_10_IRQn_Flage = 0;
static volatile uint_8 RTC_Alarm_IRQn_Flage = 0 ;
static volatile uint_8 USART3_IRQ_Active_Flage= 0;
static volatile uint_8 EXTI15_10_IRQ_Active_Flage = 0;
static uint_32 Priority_Value = 0;
static uint_32 PriorityGroupingValue = 0;
uint_8 RetVal = 0;
uint_32 MainCounter = 0;


void SystickFunc_1(void){

}

int main(void)
{

// Test Systick Driver
	RetVal = Systick_Init(1000000);

	while(1){
		Systick_WaitBlocking(1000000); // works as delay 1 micro_seconds
		Systick_SingleInterval(1000000, SystickFunc_1);
		MainCounter++;
	}

//test RCC_Driver
	HAL_RCC_GPIOA_CLK_ENABLE();
	SystemClock_Config();
//for testing the interrupt driver
	SCB_SetpriorityGrouping(SCB_PRIORITYGROUP_2);
	PriorityGroupingValue = SCB_GetpriorityGrouping();
	NVIC_SetPriority(USART3_IRQn ,SCB_PRIORITYGROUP_2);
	Priority_Value = NVIC_GetPriority(USART3_IRQn);
	NVIC_EnableIRQ(USART3_IRQn);
	NVIC_EnableIRQ(EXTI15_10_IRQn);
	NVIC_EnableIRQ(RTC_Alarm_IRQn);

	NVIC_DisableIRQ(USART3_IRQn);
	NVIC_DisableIRQ(EXTI15_10_IRQn);
	NVIC_DisableIRQ(RTC_Alarm_IRQn);

	NVIC_SetPendingIRQ(USART3_IRQn);
	NVIC_SetPendingIRQ(EXTI15_10_IRQn);
	NVIC_SetPendingIRQ(RTC_Alarm_IRQn);

	/* Loop forever */
	for(;;);
}
void USART3_IRQHandler(void){
	USART3_IRQ_Flage = 1;
	USART3_IRQ_Active_Flage = NVIC_GetActive(USART3_IRQn);
}

void EXTI15_10_IRQHandler(void){
	EXTI15_10_IRQn_Flage = 1;
	EXTI15_10_IRQ_Active_Flage = NVIC_GetActive(EXTI15_10_IRQn);
}

void RTC_Alarm_IRQHandler(void){
	RTC_Alarm_IRQn_Flage = 1;
}

void SystemClock_Config(void){
	HAL_StatusTypeDef RetStatus = HAL_OK;
	RCC_OscInitTypeDef RCC_OscInitStruct = {0};
	RCC_ClkInit_Typedef RCC_ClkInitStruct ={0};
	RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
	RCC_OscInitStruct.HSEState = RCC_HSE_ON;
	RetStatus = HAL_RCC_OscConfig(&RCC_OscInitStruct);
	RetStatus = HAL_RCC_OscConfig(NULL);

	RCC_ClkInitStruct.AHBCLKDriver = RCC_SYSCLK_DIV1;
	RCC_ClkInitStruct.APB1CLKDriver = RCC_HCLK_APB1_DIV1;
	RCC_ClkInitStruct.APB2CLKDriver = RCC_HCLK_APB2_DIV1;
	RetStatus = Hal_RCC_ClockConfig(&RCC_ClkInitStruct);

}


